# Упражнение 4: Работа с томами и монтируемыми каталогами

![Иллюстрация: Мария Фоканова](/images/podman_upr4.png)
*Иллюстрация: Мария Фоканова*

## Вступление с теорией
Контейнеры изолированы от системы, поэтому данные, созданные внутри, по умолчанию остаются внутри контейнера. Если удалить контейнер, все изменения в его файловой системе пропадут. 

**Том (volume)** – это специальное хранилище данных, связанное с контейнером, которое сохраняется независимо от жизненного цикла контейнера.
С помощью томов или монтирования каталогов хоста можно сохранять данные между запусками контейнеров или обмениваться файлами между контейнером и хостом. 

В Podman доступны:
* **Именованные томы** – управляются Podman, хранятся в спец. каталоге на хосте. Можно создавать командой ```podman volume create```.
* **Монтируемые каталоги (bind mount)** – привязка существующей папки хоста в файловую систему контейнера. Задаётся флагом ```-v host_dir:container_dir``` при запуске.
	
Использование томов необходимо для приложений, которые должны сохранять своё состояние (БД, файлы настроек и пр.) или для передачи файлов на хост.

## Практические шаги:
## 1. Пример без тома. 

Для начала продемонстрируем проблему. Выполним контейнер, который создаёт файл внутри себя, и посмотрим, что произойдет с файлом после выхода. 
	
**Запустим контейнер:**

```bash
    podman run --rm -it registry.altlinux.org/alt/python:sisyphus bash
```

Мы запускаем контейнер на базе Python образа и вручную открываем bash внутри него (переопределяя команду). 

Внутри контейнера выполним:

```bash
    echo "container log" > /tmp/log.txt
    ls /tmp
```

Видим, что файл ```log.txt``` появился в ```/tmp``` контейнера.

Теперь выйдем из контейнера (```exit```). Контейнер удалится (```--rm```). Если заново запустим новый контейнер, того файла там уже не будет — он не сохраняется вне жизни контейнера.

## 2. Использование bind mount (привязка каталога хоста). 

Смоделируем сценарий: контейнер будет записывать данные в каталог, который привязан к хосту, чтобы данные сохранялись локально. Создадим на хосте каталог для обмена, например:

```bash
    mkdir -p ~/Projects/podman-share
```

Теперь запустим контейнер, смонтировав этот каталог:

```bash
    podman run --rm -v ~/Projects/podman-share:/data registry.altlinux.org/alt/python:sisyphus python3 -c "f = open('/data/number.txt', 'w'); f.write('42'); f.close()"
```

Здесь флаг ```-v ~/podman-share:/data``` монтирует локальный каталог podman-share в контейнер как ```/data```. Python-код внутри контейнера создает файл ```/data/number.txt``` и записывает в него число 42. 

После завершения контейнера на хосте в каталоге ```/podman-share``` должен появиться файл ```number.txt```. 

Проверим это командой 
```bash
cat /podman-share/number.txt # – содержимое должно быть 42. 
```
Несмотря на удаление контейнера, файл остался на хосте.

## 3. Создание именованного тома. 
Теперь проделаем схожее с томом, управляемым Podman. 

Сначала создадим том:

```bash 
    podman volume create myvol
```

Команда вернёт имя тома (здесь мы явно указали **myvol**). 

Запустим контейнер с примонтированным томом:

```bash 
podman run --rm -v myvol:/data registry.altlinux.org/alt/python:sisyphus bash -c "echo Hello > /data/hello.txt"
```

Этот подход аналогичен предыдущему шагу, только вместо каталога хоста мы указали имя тома (**myvol**). После выполнения контейнера в том **myvol** теперь есть файл. 

Как получить к нему доступ? Можно запустить временный контейнер для проверки, снова примонтировав этот том:

```bash
    podman run --rm -v myvol:/data registry.altlinux.org/alt/alt:p10 cat /data/hello.txt
```

Здесь мы воспользовались образом **alt:p10** [можно взять минимальный образ, просто этот под руку попался. С минимальным быстрее будет], чтобы прочитать содержимое. Команда должна вывести **Hello**. 

Таким образом, том myvol сохранил данные вне конкретного контейнера. Именованные томы обычно хранятся в ```/var/lib/containers/storage/volumes/``` или аналогичном пути на хосте, но управлять ими удобнее через Podman CLI.

## 4. Права доступа и SELinux. 

Если SELinux включен, может потребоваться добавлять к монтированию суффикс **:Z** или **\:z** для коррекции контекста. В наших примерах SELinux отключен, и эта информация скорее впрок: флаг ```-v ~/share:/data:Z``` пометит каталог соответствующим контекстом, чтобы контейнер имел доступ.

## 5. Попрактикуемся с томами [Задание для самостоятельной работы]:

![Иллюстрация: Мария Фоканова](/images/scheme_volume_mount.png)

Запустим контейнер PostgreSQL (например, ```registry.altlinux.org/alt/postgresql:sisyphus```) с именованным томом для хранения БД:
```bash
podman run -d --name pg_test \
  -e POSTGRES_PASSWORD=pass \
  -e PGDATA=/var/lib/pgsql/data \
  -v pgdata:/var/lib/pgsql/data \
  --entrypoint "/usr/bin/postgres" \
  registry.altlinux.org/alt/postgresql:sisyphus -D /var/lib/pgsql/data
```

рабоча команда

```bash
  podman run -d \
  --name pg_test \
  -e POSTGRES_PASSWORD=pass \
  -e PGDATA=/var/lib/pgsql/data \
  -v pgdata:/var/lib/pgsql/data \
  registry.altlinux.org/sisyphus/postgresql:16.6 \
  bash -c "initdb -D /var/lib/pgsql/data && postgres -D /var/lib/pgsql/data"
```

Это запустит СУБД Postgres, сохраняя данные в том pgdata. 
Проверим работу: ```podman ps```
Контейнер должен быть в статусе ```Up```.

### Поработаем с Базой Данных. 
Попробуем подключиться:
```bash
podman exec -it pg_test psql -U postgres
```
Должны получить вывод:
```bash
psql (16.6)
Type "help" for help.

postgres=# 
```

### Создадим базу данных и таблицу.

```sql
CREATE DATABASE testdb;
\c testdb;
CREATE TABLE users (id SERIAL PRIMARY KEY, name TEXT);
INSERT INTO users (name) VALUES ('Иван'), ('Анна');
SELECT * FROM users;
```

Удалим контейнер командой 
```bash
podman rm -f pg_test
```

Затем запустим новый контейнер с тем же монтированием:
```bash
podman run -d --name pg_test2 -e POSTGRES_PASSWORD=pass -v pgdata:/var/lib/postgresql/data postgres:15
```

```bash
podman run -d --name pg_test2 \
  -e POSTGRES_PASSWORD=pass \
  -e PGDATA=/var/lib/pgsql/data \
  -v pgdata:/var/lib/pgsql/data \
  --entrypoint "/usr/bin/postgres" \
  registry.altlinux.org/alt/postgresql:sisyphus -D /var/lib/pgsql/data
```

Подключимся к БД в контейнере:
```bash
podman exec -it pg_test2 psql -U postgres
```
Убедимся, что ранее созданная база и таблица с данными существуют, т.е. данные предыдущей БД сохранились:

```bash
postgres=# \c testdb;
You are now connected to database "testdb" as user "postgres".
testdb=# SELECT * FROM users;
 id |   name   
----+----------
  1 | Иван
  2 | Анна
(2 rows)
```

## 6. Попробуем смонтировать в контейнер какой-либо системный каталог в режиме только-чтение. 

Например:
```bash
    podman run --rm -v /etc:/mnt:ro registry.altlinux.org/alt/alt:sisyphus ls /mnt
```

Мы наблюдаем, что контейнер может увидеть файлы хоста в ```/etc```, но не может их изменить (флаг ```ro``` делает монтирование ```read-only```). Такой приём полезен для передачи внутрь контейнера конфигураций или данных, которые не должны модифицироваться контейнером.

## Ожидаемый итог: 
мы научились пользоваться внешним хранением данных для контейнеров. Результатом шагов было сохранение файлов на хосте. 

При монтировании каталога хоста, файл, созданный контейнером, появился на хостовой файловой системе.

При использовании именованного тома данные сохранились в томе и были доступны при повторном подключении тома к другому контейнеру. В самостоятельном задании контейнер Postgres при повторном запуске с тем же томом должен обнаружить существующие данные (базу) и продолжить работу с ними. А пример с read-only монтированием /etc должен перечислить файлы хоста без ошибок доступа, но попытка изменения файла внутри контейнера вызвала бы ошибку. 

В этом материале мы научились сохранять и делать доступными данные контейнеров.